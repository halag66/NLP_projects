import math
from sys import argv


class My_CKY:
    # class for parsing using CKY algorithm, my implementation
    def __init__(self, grammar_file, sentence_file, output_file):
        file = open(grammar_file, 'r')
        self.start_symbol = ''
        grammar = file.readlines()
        self.output = output_file
        self.grammar = self.read_grammar(grammar)  # dictionary of rules
        file2 = open(sentence_file, 'r')
        self.sentences = file2.readlines()


    def call_func(self):
        for line in self.sentences:
            self.print_Pars(self.create_chart(line), line)



    def read_grammar(self, grammar):
        rules = {}
        for i, line in enumerate(grammar):
            rule = line.replace("->", "").split()
            if i == 0:
                self.start_symbol = rule[1]
            if rule[1] not in rules:
                rules[rule[1]] = []
            if rule.__len__() > 3:
                rules[rule[1]].append([rule[0], rule[2], rule[3]])  # [prob, non-terminal] or [prob, ter, ter]
            else:
                rules[rule[1]].append([rule[0], rule[2]])
        return rules

    def create_chart(self, sentence):
        sentence = sentence.split()
        length = sentence.__len__()
        chart = [[[] for x in range(length - y)] for y in range(length)]
        for j, word_col in enumerate(sentence):
            for rules in self.grammar:
                for rule in self.grammar[rules]:
                    if word_col in rule:
                        chart[0][j].append([rules, math.log(float(rule[0])), rule, []])
            if not chart[0][j]:  # if word isn't in grammar, can't derive sentence from grammar
                return None
        for words_to_consider in range(2, length + 1):
            for starting_cell in range(0, length - words_to_consider + 1):
                for left_size in range(1, words_to_consider):
                    right_size = words_to_consider - left_size
                    left_side = chart[left_size - 1][starting_cell]
                    right_side = chart[right_size - 1][starting_cell + left_size]
                    for rules in self.grammar:
                        for rule in self.grammar[rules]:
                            left_nodes = [n for n in left_side if n[0] == rule[1]]
                            if left_nodes:
                                right_nodes = [n for n in right_side if n[0] == rule[2]]
                                if right_nodes:
                                    for index, pos_rule in enumerate(left_nodes):
                                        if not chart[words_to_consider - 1][starting_cell]:
                                            chart[words_to_consider - 1][starting_cell].append([rules, math.log(float(rule[0])) + pos_rule[1] + right_nodes[index][1], rule,
                                                                                                [left_size - 1, starting_cell, right_size - 1, starting_cell + left_size, left_side.index(left_nodes[0]), right_side.index(right_nodes[0])]])
                                        if chart[words_to_consider - 1][starting_cell][0][1] < math.log(float(rule[0])) + pos_rule[1] + right_nodes[index][1]:
                                            chart[words_to_consider - 1][starting_cell].append([rules, math.log(float(rule[0])) + pos_rule[1] + right_nodes[index][1], rule,
                                                                                                [left_size - 1, starting_cell, right_size - 1, starting_cell + left_size, left_side.index(left_nodes[0]), right_side.index(right_nodes[0])]])

        if not chart[length - 1][0]:
            return None
        else:
            if chart[length - 1][0][0][0] != self.start_symbol:
                return None
        return chart

    def print_tree(self, chart, i, j, space, rule_i):
        new_file = open(self.output + "output.txt", "a+", encoding='utf-8')
        if i == 0:
            new_file.write(space + chart[i][j][rule_i][0] + " >" + chart[i][j][rule_i][2][1] + "\n")
            new_file.close()
            return
        else:
            new_file.write(space + chart[i][j][rule_i][0] + "\n")
            new_file.close()
        self.print_tree(chart, chart[i][j][0][3][0], chart[i][j][0][3][1], space + "   ", chart[i][j][0][3][4])
        self.print_tree(chart, chart[i][j][0][3][2], chart[i][j][0][3][3], space + "   ", chart[i][j][0][3][5])



    def print_Pars(self, chart, sentence):
        new_file = open(self.output + "output.txt", "a+", encoding='utf-8')
        new_file.write("Sentence: " + sentence)
        if not chart:
            new_file.write("\n  *** This sentence is not a member of the language generated by the grammar *** \n\n\n")
            new_file.close()
            return
        sen = sentence.split()
        length = sen.__len__()
        new_file.write("Parsing:" + "\n")
        new_file.close()
        self.print_tree(chart, length-1, 0, "", 0)
        new_file = open(self.output + "output.txt", "a+", encoding='utf-8')
        new_file.write("Log Probability: " + str(chart[length - 1][0][0][1]) + "\n\n\n")
        new_file.close()





if __name__ == '__main__':

    input_grammar = argv[1]         # The name of the file that contains the probabilistic grammar
    input_sentences = argv[2]       # The name of the file that contains the input sentences (tests)
    output_trees = argv[3]        # The name of the output file
    obj = My_CKY(input_grammar, input_sentences, output_trees)
    obj.call_func()






